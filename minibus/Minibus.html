<!DOCTYPE html>
<html>
    <head>
        <title>Minibus Example</title>
        <style>
            * { box-sizing: border-box }
            html { width: 100%; height: 100%; padding: 0; margin: 0; }
            body { width: 100%; height: 100%; padding: 20px; margin: 0; }
            #container { width: 100%; height: calc(100% - 50px) }
            #btnDrive { height: 40px; width: 50%; float: left; margin: 10px 0 0; background-color: orange; color: black }
            #sldrSpeed { height: 40px; width: 49%; float: left; margin: 10px 0 0 1%; }
        </style>
    </head>
    <body onLoad="onLoad()">
        <div id="container"></div>
        <button id="btnDrive" type="button">Start/Stop Driving</button>
        <input id="sldrSpeed" type="range" min="0.1" max="2" step="0.1" value="0.5" />

        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r127/three.min.js" integrity="sha512-U4J4PbEJ2TMjFqPUSiKq7LLTHuEkPZVo0jl2fomi9pT7UAExh4xVi8KmoR7EfmyigH95aA68zpW7y3XzuoSurQ==" crossorigin="anonymous"></script>
        <script>
            let renderer = null,
            scene = null,
            camera = null,
            minibusContainer = null,
            wheels = [],
            drive = false,
            speedInDegrees = 0.5;

            // The reason for using a JavaScript closure, is to leverage "instancing" â€“ creating the geometry and
            //  material for the various parts of a wheel, once, then reusing it to create numerous wheel instances.
            const buildWheel = (function() {
                const rimMaterial = new THREE.MeshPhongMaterial({ color: 0x909090 });
                const rimGeometry = new THREE.TorusGeometry(0.65, 0.25, 3, 32);

                const tyreMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const tyreGeometry = new THREE.TorusGeometry(1.6, 0.4, 10, 32);
                
                // Build the rim spokes
                const NUM_VERTICES = 17;
                const vertexArray = new Float32Array(NUM_VERTICES * 3);
                const indices = [];

                // Create the vertices of the spokes
                let i = 0;
                vertexArray[i++] = 0; vertexArray[i++] = 0; vertexArray[i++] = -0.2;
                vertexArray[i++] = 0; vertexArray[i++] = 0; vertexArray[i++] = 0.2;
                for (let t = 0; t < 360; t += 72) {
                    vertexArray[i++] = 0.8 * Math.cos(deg2rad(t - 15)); vertexArray[i++] = 0.8 * Math.sin(deg2rad(t - 15)); vertexArray[i++] = 0;
                    vertexArray[i++] = 0.8 * Math.cos(deg2rad(t + 15)); vertexArray[i++] = 0.8 * Math.sin(deg2rad(t + 15)); vertexArray[i++] = 0;
                    vertexArray[i++] = 0.2 * Math.cos(deg2rad(t + 36)); vertexArray[i++] = 0.2 * Math.sin(deg2rad(t + 36)); vertexArray[i++] = 0;
                }

                // Simulate a triangle fan using vertex indices (front facing side of the spokes)
                for (i = 3; i < NUM_VERTICES; ++i) {
                    indices.push(1, i - 1, i);
                }
                indices.push(1, NUM_VERTICES - 1, 2); // Close the triangle fan

                // Simulate a triangle fan using vertex indices (back facing side of the spokes)
                for (i = 3; i < NUM_VERTICES; ++i) {
                    indices.push(0, i, i - 1);
                }
                indices.push(0, 2, NUM_VERTICES - 1); // Close the triangle fan

                const spokesGeometry = new THREE.BufferGeometry();
                spokesGeometry.setIndex(indices);
                spokesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertexArray, 3));
                spokesGeometry.computeVertexNormals();
               
                return function() {
                    const wheel = new THREE.Object3D();
                    const spokesMesh = new THREE.Mesh(spokesGeometry, rimMaterial);
                    const rimMesh = new THREE.Mesh(rimGeometry, rimMaterial);
                    const tyreMesh = new THREE.Mesh(tyreGeometry, tyreMaterial);
                    tyreMesh.scale.set(0.5, 0.5, 1);
                    wheel.add(spokesMesh);
                    wheel.add(rimMesh);
                    wheel.add(tyreMesh);

                    return wheel;
                }
            })();
            
            function buildMinibus() {
                const minibus = new THREE.Object3D();

                // Instantiate and position four wheels.
                for (let t = 45; t < 360; t += 90) {
                    const xSign = Math.sign(Math.cos(deg2rad(t))), zSign = Math.sign(Math.sin(deg2rad(t)));
                    const wheel = buildWheel();
                    wheel.position.set(xSign * 3, -1, zSign * 1.53);
                    wheels.push(wheel);
                    minibus.add(wheel);
                }

                const bodyShape = new THREE.Shape();
                bodyShape.moveTo(-4.5, -1);
                bodyShape.lineTo(-4.5, 1);
                bodyShape.lineTo(4.5, 1);
                bodyShape.lineTo(4.5, -1);
                bodyShape.absarc(3, -1, 1.1, 0, Math.PI, false);
                bodyShape.absarc(-3, -1, 1.1, 0, Math.PI, false);
                bodyShape.closePath();

                const bodyGeometry = new THREE.ExtrudeGeometry(bodyShape, { depth: 3.5, bevelEnabled: false });
                const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x32527B });
                const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial) ;
                bodyMesh.position.z = -1.75;
                minibus.add(bodyMesh);

                const glassShape = new THREE.Shape();
                glassShape.moveTo(-4.4, 1);
                glassShape.lineTo(-4.4, 2.5);
                glassShape.lineTo(3.9, 2.5);
                glassShape.lineTo(4.4, 1);
                glassShape.closePath();

                const glassGeometry = new THREE.ExtrudeGeometry(glassShape, { depth: 3.3, bevelEnabled: false });
                const glassMaterial = new THREE.MeshPhongMaterial({ color: 0x000000, transparent: true, opacity: 0.6 });
                const glassMesh = new THREE.Mesh(glassGeometry, glassMaterial);
                glassMesh.position.z = -1.65;
                minibus.add(glassMesh);

                const carRoofGeometry = new THREE.BoxGeometry(8.5, 0.1, 3.5);
                const carRoofMesh = new THREE.Mesh(carRoofGeometry, bodyMaterial);
                carRoofMesh.position.set(-0.25, 2.55, 0);
                minibus.add(carRoofMesh);

                const rearRoofSupportGeometry = new THREE.BoxGeometry(0.8, 1.5, 0.2);

                const leftRearRoofSupportMesh = new THREE.Mesh(rearRoofSupportGeometry, bodyMaterial);
                leftRearRoofSupportMesh.position.set(-4.1, 1.75, 1.65);
                minibus.add(leftRearRoofSupportMesh);

                const rightRearRoofSupportMesh = new THREE.Mesh(rearRoofSupportGeometry, bodyMaterial);
                rightRearRoofSupportMesh.position.set(-4.1, 1.75, -1.65);
                minibus.add(rightRearRoofSupportMesh);

                const roofSupportGeometry = new THREE.BoxGeometry(0.3, 1.676, 0.2);

                const leftFrontRoofSupportMesh = new THREE.Mesh(roofSupportGeometry, bodyMaterial);
                leftFrontRoofSupportMesh.rotation.z = deg2rad(17.354);
                leftFrontRoofSupportMesh.position.set(4.1, 1.75, 1.65);
                minibus.add(leftFrontRoofSupportMesh);

                const rightFrontRoofSupportMesh = new THREE.Mesh(roofSupportGeometry, bodyMaterial);
                rightFrontRoofSupportMesh.rotation.z = deg2rad(17.354);
                rightFrontRoofSupportMesh.position.set(4.1, 1.75, -1.65);
                minibus.add(rightFrontRoofSupportMesh);

                const leftRearMiddleRoofSupportMesh = new THREE.Mesh(roofSupportGeometry, bodyMaterial);
                leftRearMiddleRoofSupportMesh.position.set(-1.0, 1.7, 1.65);
                minibus.add(leftRearMiddleRoofSupportMesh);

                const rightRearMiddleRoofSupportMesh = new THREE.Mesh(roofSupportGeometry, bodyMaterial);
                rightRearMiddleRoofSupportMesh.position.set(-1.0, 1.7, -1.65);
                minibus.add(rightRearMiddleRoofSupportMesh);

                const leftFrontMiddleRoofSupportMesh = new THREE.Mesh(roofSupportGeometry, bodyMaterial);
                leftFrontMiddleRoofSupportMesh.position.set(2.0, 1.7, 1.65);
                minibus.add(leftFrontMiddleRoofSupportMesh);

                const rightFrontMiddleRoofSupportMesh = new THREE.Mesh(roofSupportGeometry, bodyMaterial);
                rightFrontMiddleRoofSupportMesh.position.set(2.0, 1.7, -1.65);
                minibus.add(rightFrontMiddleRoofSupportMesh);

                const headLightGeometry = new THREE.SphereGeometry(0.3, 12, 12);
                const headLightMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });

                const leftHeadLightMesh = new THREE.Mesh(headLightGeometry, headLightMaterial);
                leftHeadLightMesh.scale.x = 0.2;
                leftHeadLightMesh.position.set(4.5, 0, 1.2);
                minibus.add(leftHeadLightMesh);

                const rightHeadLightMesh = new THREE.Mesh(headLightGeometry, headLightMaterial);
                rightHeadLightMesh.scale.x = 0.2;
                rightHeadLightMesh.position.set(4.5, 0, -1.2);
                minibus.add(rightHeadLightMesh);

                const tailLightGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.3);
                const tailLightMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0909 });

                const leftTailLightMesh = new THREE.Mesh(tailLightGeometry, tailLightMaterial);
                leftTailLightMesh.position.set(-4.5, 0, 1.61);
                minibus.add(leftTailLightMesh);

                const rightTailLightMesh = new THREE.Mesh(tailLightGeometry, tailLightMaterial);
                rightTailLightMesh.position.set(-4.5, 0, -1.61);
                minibus.add(rightTailLightMesh);

                return minibus;
            }

            const run = (function() {
                let acceleration = 0;
                return function() {
                    renderer.render(scene, camera);

                    if (drive) {
                        acceleration = (acceleration += 0.01) > speedInDegrees ? speedInDegrees : acceleration;
                    } else {
                        acceleration = (acceleration /= 1.05) < 0.001 ? 0 : acceleration;
                    }
                    minibusContainer.rotation.y += deg2rad(acceleration);
                    wheels[0].rotation.z = wheels[1].rotation.z = wheels[2].rotation.z = wheels[3].rotation.z -= deg2rad(acceleration * 32.5);
                    
                    requestAnimationFrame(run);
                }
            })();

            function onLoad() {
                const container = document.getElementById('container');
                const width = container.clientWidth, height = container.clientHeight;
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setClearColor(0x87CEFF);
                container.appendChild(renderer.domElement);
            
                camera = new THREE.PerspectiveCamera(45, width / height, 1, 300);
                camera.position.z = 50;

                const light = new THREE.DirectionalLight(0xffffff, 1.5);
                light.position.set(-0.5, 0, 1);

                const groundGeometry = new THREE.PlaneGeometry(500, 500);
                const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x004D00 });
                const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
                groundMesh.rotation.x = deg2rad(-90);
                groundMesh.position.y = -2.01;

                const trackGeometry = new THREE.RingGeometry(30, 35, 128);
                const trackMaterial = new THREE.MeshBasicMaterial({ color: 0x9D9DD0 });
                const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
                trackMesh.rotation.x = deg2rad(-90);
                trackMesh.position.y = -2.0;

                const minibus = buildMinibus();
                minibus.position.set(0, 0, 32.5);
                minibusContainer = new THREE.Object3D();
                minibusContainer.add(minibus);

                scene = new THREE.Scene();
                scene.add(groundMesh);
                scene.add(light);
                scene.add(trackMesh);
                scene.add(minibusContainer);
                scene.rotation.x = deg2rad(2);

                document.body.onresize = function() {
                    const width = container.clientWidth, height = container.clientHeight;
                    renderer.setSize(width, height);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                }
                document.getElementById("btnDrive").onclick = function() {
                    drive = !drive;
                }
                document.getElementById("sldrSpeed").onchange = function(event) {
                    speedInDegrees = parseFloat(event.target.value);
                }

                run();
            }

            function deg2rad(degrees) {
                return degrees * Math.PI / 180;
            }
        </script>
    </body>
</html>